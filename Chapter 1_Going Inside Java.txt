1p<자바 속으로>자바는 "간단하고, 건장하고, 객체 지향적이고, 플랫폼 독립적이고, 멀티쓰레드이고, 역동적이고, 범용적인 프로그래밍 환경'이라고 묘사되어져 왔다. 이에 따라 자바는 알아차릴 수 없을 정도로의 다양한 환경으로 확장되었다. 최근에는 
마이크로 프로세서에도 자바를 사용한다. 자바를 큰 기업체에서도 작은 부품들을 위해 사용하고, 핸드폰에서 주 컴퓨터같은 장치에도 사용한다.  이렇게 다양한 범위의 환경을 지원하기 위해 코어 클래스들을 중심으로 많은 API들과 버전들이 발전되어졌다.좋은 
자바 프로그래머가 되기 위해, 기초를 잘 아는 것이 중요하다. UI가 아무리 좋아도, 코드는 많고, 메모리가 부족하다면 유저는 행복하지 않을 것이다. 이 책은 자바개발자로써 다양한 개발을 가능하게 해주는 것이 아닌 독자가 매일 마주칠 수 있는 일반적인 
작업을 어떻게 처리할 것인가에 관한 것이다. 책을 보면서 독자는 자바 애플리케이션의 품질을 높일 수 있는 스레딩이나 메모리 관리 같은 코어 랭귀지의 몇가지 특성을 조사할 것이다.자바가 유명해질 수 있었던 특성인 적응력의 핵심은 플랫폼에 독립적이라는 
것이다. "write once, run anywhere"(WORA) 의 능력은 자바코드가 운영체제에서 분리될 수 있도록 자바 자체가 운영하고 특히 추상적인 실행환경을 사용한다는 것에서 유래되었다. 이 책의 대부분은 프로그래밍 언어와 자바 API에 대해 알아볼 
것이지만 이 챕터에서는 Java Virtual Machine (JVM)과 함께 자바가 어떻게 운영되는 지에 대한 기반에 대해 알아볼 것이다. 자바의 내부 구조를 이해하는 것은 언어에 대해 더 많은 이해를 할 수있고, 따라서 더 나은 프로그래머로 만들어 줄 
것이다.다음은 이 챕터에서 우리가 배울 내용이다.
	* 자바 플랫폼의 다양한 구성요소
	* JVM이 어떻게 자바를 플랫폼 독립적으로 만들어주는지
	* 자바 프로그램을 실행할 때 어떤 일이 일어나는지
	* 자바 클래스 파일은 실제로 어떤 것을 포함하고 있는지
	* JVM이 동작할 때 필요한 주요 도구

처음으로, 자바가 실제로 뭔지 살펴보자.2p<자바 아키텍쳐>자바가 단지 애플리케이션 개발 (소스코드를 작성하고 바이트코드로 컴파일 하는 것) 을 위한 프로그래밍 언어라고 생각하기 쉽다. 그러나, 프로그래밍 언어는 자바의 한 요소일 뿐이며, 자바는 플랫폼 
독립성을 포함하여 많은 이점을 주는 아키텍쳐에 기반한다.완벽한 자바 아키텍쳐는 다음 4가지 구성요소의 조합이다:
	* 자바 프로그래밍 언어
	* 자바 클래스 파일 포맷
	* 자바 API들
	* JVM

그래서 자바로 개발할 때, 즉 자바 프로그래밍 언어로 작성 후 자바 클래스 파일로 컴파일하고, 차례로 JVM 안에서 실행된다. 사실, 요즘날 자바 언어는 자바 플랫폼을 사용하는 하나의 가능한 옵션일 뿐이다. 예를 들어 스칼라는 자바 언어의 대안으로써 많은 
관심을 불러 일으켰고 자바 기술을 이용하는 많은 언어 중 하나일 뿐이다.Java Runtime Environment (JRE) 로 알려져있는 JVM과 자바 플랫폼을 구성하는 핵심 클래스의 조합은 사용중인 운영체제에 상관없이 올릴 수 있다. Figure 1-1은 
애플리케이션과 운영체제 사이에서 자바 기능의 두 가지 양상을 보여준다.3p자바 API는 비슷한 주제의 패키지들로 조직된 미리 짜여진 코드이다. 자바 API는 3개의 메인 플랫폼으로 나뉜다:
	* Java Platform, Standard Edition (Java SE): 코어 자바 클래스들과 GUI 클래스들을 포함한 플랫폼
	* Java Platform, Enterprise Edition (Java EE): 보다 복잡한 "enterprise" 애플리케이션 개발을 위한 클래스와 인터페이스(서블릿, JavaServer Pages, Enterprise JavaBeans, 등)를 포함한다.
	* Java Platform, Micro Edition (Java ME): 이 플랫폼은 자바의 근원으로 되돌아간다. 소비자 생산품(ex. 블루레이 디스크 플레이어, 핸드폰, 스마트 장치 같은 하드웨어의 다양한 종류) 을 위한 최적화된 런타임 환경을 제공한다.

<자바 가상 머신>강력한 자바 애플리케이션의 다양한 측면들을 파헤치기 전에, 이 섹션에서는 그것을 가능하게 해주는 엔진에 대해 알아볼 것이다. 그 엔진의 이름은 추상적인 컴퓨팅 머신인 JVM이며,  컴파일된 자바 프로그램을 해석한다.C나 C++같은 다름 
프로그래밍 언어들은 특정한 프로세서이거나 OS이기도 한 컴파일러가 소스코드를 실행가능하도록 컴파일 해준다. 이 실행가능한 파일은 자급자족이고 머신 위에서 실행할 수 있다.이에 대한 단점은 이식성의 부족이다: 한 OS아래에서 컴파일된 코드는 다른 
OS에서 실행될 수 없으며 다른 시스템에서 실행할 때마다 재컴파일을 해야한다. 게다가, Intel x86, SPARC 같은 프로세서가 같은 OS를 지원한다 하더라도 공급자에 특정한 컴파일러 특징 때문에 특정 프로세서 그룹을 사용하는 OS에 의해 컴파일된 코드는 
다른 타입의 프로세서에서 실행되지 않을 수도 있다.이 문제는 인터넷을 쓰는 애플리케이션을 사용할 때 특히 발생한다. 이 애플리케이션들은 다양한 브라우저를 통한 다양한 플랫폼의 다양한 OS에서 실행하는 유저들을 의도로 한다. 이 문제를 풀기 위한 유일한 
방법은 플랫폼 독립적인 언어를 개발하는 것이었다.1990년대 초반에, Sun Microsystems의 개발자들은 소비자 전자 기기에 사용하기 위해 플랫폼 독립적인 언어로 개발하였지만 불행하게도 시대를 너무 앞서간 것이었고 그리하여 쓰지 않게 되었다. 인터넷의 
출현으로, 이 개발자들은 그들이 만든 그 언어의 더 굉장한 잠재력을 보게 되었고 이것이 JAVA의 탄생 배경이다.자바 언어의 이식성의 핵심은 자바 컴파일러의 결과가 실행가능한 표준 코드가 아니라는 점이다. 대신, 자바 컴파일러는 bytecode 프로그램이라 
불리는 최적화된 지침서를 생성한다. 바이트코드는 등록된 패턴을 따르는 바이트의 연속이고, 나중에 상세하게 다룰 것이다. 바이트코드 프로그램은 JVM이라 알려져 있는 런타임 시스템에 의해 해석되고, JVM이 설치된 곳에서는 한 플랫폼에서 생성된 
바이트코드 프로그램이 다른 플랫폼에서도 실행될 수 있다.JVM의 특정 사항이 플랫폼마다 다를 수 있지만 일반적으로 적용된다. 즉, 리눅스 워크스테이션에서 컴파일된 자바 프로그램이 PC나 Mac에서 실행될 수 있는 것이다. 표준적인 방법의 자바 언어로 
소스코드를 짜고, 바이트코드 프로그램으로 컴파일 되고, 각 JVM이 각 플랫폼에 특정적인 native call을 통해 바이트코드를 (즉, 특정 프로세서가 이해할 수 있는 언어로) 해석한다 . 이 추상화는 다양한 운영체제 아카이브(ex. 플랫폼 간 일관된 방식인 
프린팅, 파일 접근, 하드웨어 처리 같은 명령)를 다룰 수 있는 방법이다.4p바이트코드의 한 특징 (어쩌면 단점이 될 수도 있는) 은 실행되고 있는 머신의 프로세서에 의해 바로 실행되지 않는다는 점이다. 바이트코드는 바이트코드를 인터프리트하는 JVM을 
통해 실행되고, 이것이 왜 자바가 interpreted language라 불리는 지에 대한 이유이다. 현실적으로, 자바가 순수하게 인터프리터 언어라는 것은 사라진지 오래고, 현재 JVM 구현체의 거의 대부분의 아키텍쳐는 인터프리터와 컴파일의 혼합이다. 
인터프리션은 컴파일에 상대적으로 처리 속도가 느리고, 자바가 다른 언어보다 느리다는 명성을 얻었을 때가 자바가 순수 인터프리터 언어였을 때다. 그러나 새로운 인터프리트/컴파일의 하이브리드 모델은  모든 것에 적절하지만 리소스를 집약적으로 사용하며 
다른 프로그래밍 언어들과 자바 프로그램의 속도 차 이슈를 잠재우게 되었다.Table 1-1 은 컴파일 언어와 인터프리터 언어의 목록을 보여준다.  자바가 native application(C나 C++로 작성된 것)과 함께 인터페이스에 대한 API를 포함하고 있다는 
것도 주목할 만하다. 이 API는 JNI(Java Native Interface) API 이고 개발자가 비자바 언어를 자바 코드에서 호출 하거나 그 반대로도 할 수 있도록 한다. JNI는 두 가지를 실현하는데, 하나는 자바에서 직접적으로 처리할 수 없는 OS에 특정적인 
특징들을 애플리케이션에서 다룰 수 있다는 점이다. 요점만 말하면, JNI는 자바 애플리케이션의 퍼포먼스가 중요한  구간에서 C나 C++같은 컴파일 언어로 구현된 함수들을 사용할 수 있게 해준다. 하지만 JNI를 사용하는 것은 네이티브 코드가 범용적으로 
platform-specific 이기 때문에 자바의 플랫폼 독립적인 특성을 일부 부정하는 것이며, 게다가 기능적으로 네이티브 코드에 의존하는 것이 있다면 자바 코드도 타깃 플랫폼에 묶일 것이다.  머신 이식성이 작동하려면, JVM은 상당히 엄격하게 정의되어야 
하고 그것은 JVM specification 에 의해 달성하게 된다. specification은 JVM에 의해 인식되는 바이트코드의 포맷 뿐만 아니라 JVM에 의해 반드시 구현되야 하는 특징과 기능들을 명령한다. JVM specification은 자바 언어의 플랫폼 독립성을 
보장하는 것이다; 다음은 Oracle 웹 사이트에서 찾을 수 있다.  이 문맥에서, JVM을 따르는 것은 다음 세가지 중 하나를 의미할 수 있다:
	* 추상적인 명세 (ex. JAVA8 명세)
	* 명세의 실체적인 구현
	* 런타임 실행 환경

<JVM 구현체들의 차이점>  자바의 창시 회사인 Sun Microsystems는 시초에 JVM를 포함한 그들만의 다양한 자바 기술의 구현체드를 제공했고 그것들은 reference implementations라 불린다. 그러나. Sun(지금은 Oracle, 2010년에 Sun을 
인수했다.)은 다른 조직들도 그들만의 구현체들을 생성할 수 있도록 라이센스를 허가하였다. 비록 JVM의 참조 구현과 다른 자바 기술들이 널리 쓰이긴 하지만, 사용 가능한 유일한 구현체와는 거리가 멀고, 라이센트 사용자들은 IBM, Apple, 
Hewlett-Packard와 다른 많은 조직들을 포함한다.  2006년에, Sun은 표준과 참조 구현을 단단히 통제했던 기존의 소유 모델에서 오픈 모델로 변환하였다. 이 변화는 다음을 포함하여 자바가 어떻게 관리되는지에 대한 변화를 가져왔다:
	* 전체 소스 코드는 공개적으로 제공되거나, 최소한 Sun이 관련 라이센스 제한을 합법적으로 제공할 수 있다.
	* 자바의 변경되거나 추가된 사항은 Sun 내부적으로 다루는 것이 아닌 JCP(Java Community Process)에 다루게 되었다. JCP는 열려있고 비록 Sun(지금은 Oracle)이 의사 결정 과정에 중요학 역할이긴 하지만 미래의 자바에 관한 의사 결정에 
협업 프로세스를 가지고 있다.
	* 자바의 참조 구현은 현재 오픈 소스로 생산되고 그것을 OpenJDK(Open Java Development Kit)이라 부른다.

  많은 JVM 구현체들은 아직 존재하지만 OpenJDK는 가장 일반적으로 사용된 구현체로 알려져 있다.   왜 다른 버전의 JVM이 존재하는가? 기억해라, JVM 명세는 JVM의 요구되는 기능들만 설정되어 있고 그것이 어떻게 구현되야 하는지는 다루지 않는다. 
JAVA의 사용량을 극대화 시키기 위해 주어진 플랫폼에서 창의성을 발휘할 수 있는 몇 가지 유연성이 주어졌다. 가장 중요한 점은 구현이 어떤식으로 되어있든, JVM은 자바 명세에 정의되어있는 가이드라인을 반드시 준수해야 한다는 것이다. 플랫폼 
독립성이라는 관점에서 이 의미는 JVM은 어떤 플랫폼에서 생성되든 올바른 바이트코드는 해석할 수 있어야 한다는 것이다.<런타임 실행 환경으로써의 JVM>  자바 애플리케이션을 실행할 때 마다, 사실 애플리케이션은 JVM 인스턴스 안에서 실행되고 각 
분리된 애플리케이션은 각각의 JVM인스턴스를 소유하고 있다. 지금까지 자바는 바이트코드라 불리는 소스코드의 인터프리트된 형태를 사용하는 것을 봐왔지만, 어떻게 자바 프로그래밍 언어가 기반하는 OS가 이해할 수 있는 지침으로 해석될 수 있는가?  JVM 
스펙이 이 프로세스의 추상적인 내부 아키텍쳐를 정의한다. 이제 내부 아키텍쳐의 구성요소들을 배울 것이지만 높은 수준에선 클래스파일(컴파일된 자바 파일은 확장자가 .class인 클래스파일을 가지고 있다) 이 실행 엔진에 의해 실행될 수 있는 JVM으로 
로딩된다. 바이트코드를 실행하면, JVM은 네이티브 메소드를 통해 기반하는 OS와 상호작용하고 네이티브 메소드의 구현체는 특정 플랫폼의 특정 JVM 구현체에 묶여있다.  이전 컴포넌트에 더하여, JVM은 코드 실행에 관련된 임시 데이터(ex. 로컬 변수, 
실행 중인 메소드 등)를 저장할 목적으로 메모리를 필요로 한다. 다음에 설명할 이 데이터는 JVM의 런타임 데이터 영역 내부에 저장된다.<JVM의 런타임 데이터 영역>  비록 독립적인 구현체는 플랫폼마다 조금씩 다를 수 있지만, 모든 JVM은 반드시 다음 
그림에 있는 런타임 컴포넌트들을 제공해야한다.   <힙>  힙은 동적이나 임시 메모리 할당을 위한 가용 메모리이다. 힙은 클래스와 배열 객체를 위한 메모리를 제공하는 런타임 데이터 영역이다. 자바 안에서 클래스나 배열 객체가 생성되면, 그에 필요한 
메모리가 JVM이 시작될 때 힙에 할당된다. 힙 메모리는 나중에 배울 garbage collection이라 알려져 있는 저장소 자동 관리 시스템에 의해 객체나 배열의 참조값이 더 이상 존재하지 않을 때 회수된다.  JVM 스펙은 힙이 어떻게 구현되야 하는지 
정의하지 않는다; JVM의 개인적인 구현체의 창의성에 맡긴다. 힙 사이즈는 일정하거나, 수요에 따라 증가하거나, 불필요하게 크다면 줄어들게 할 수 있다. 프로그래머는 힙 사이즈의 초기값을 정할 수 있다; 예를 들어 Win32나 솔라리스 구현체에서는 -mx 
커맨드 라인 옵션으로 할 수 있다. 힙 메모리는 근접할 필요는 없다. 만양 힙 메모리가 초과되고 더 이상 할당받을 수 없으면 시스템은 OutOfMemoryError 익셉션을 생성할 것이다.<스택>  자바 stack frame은 메소드 호출 상태를 저장한다. 
스택프레임은 부분적인 결과 데이터를 저장하고, 메소드 호출 시 쓰이는 로컬 변수들 같은 메소드 실행 환경과 메소드의 operand stack을 포함한다. 피연산자 스택은 파라미터와 바이트코드 명령에 대한 값을 반환값을 저장한다. 실행 환경은 메소드 
호출과 관련된 다양한 포인터를 포함한다.  Frames는  JVM 스택을 구성하는 컴포넌트이다. 부분적인 결과값, 데이터, 메소드 반환값을 저장한다. 또한 동적 링킹을 수행하고 런타임 익셉셥을 발생시킨다. 프레임은 메소드가 호출될 때 생성되고 어떤 
이유로든 메소드가 종료될 때 파괴된다. 프레임의 구성요소는 로컬 변수 배열, 피연산자 스택, 현재 실행 중인 메소드의 클래스의 런타임 상수 풀이다.  JVM이 자바 코드를 실행하면, 지금 실행 중인 메소드에 상응하는 오직 하나의 프레임이 어느 한 
순간에 활성화된다. 이 프레임은 current frame이라 부른다. current frame의 메소드가 current method이며 그 메소드를 포함하는 클래스가 current class이다. 쓰레드가 메소드를 호출하면(쓰레드는 자신만의 statck을 가지고 있다), 
JVM이 현재 프레임이 될 새 프레임을 생성하고 그 쓰레드의 stack에 push한다.  힙과 마찬가지로, JVM 스펙은 스택 프레임이 어떻게 구현되는지에 대한 구체적인 명세를 하지 않는다. 스택 또한 고정 size이거나 필요에 따라 확장하거나 축소될 수 
있다. 프로그래머는 스택의 초기 최대, 최소 값을 제어할 수 있다. 다시 Win32나 솔라리스에선 커맨드 라인 옵션 -ss와 -oss를 사용한다. 연산이 가용 스택 사이즈를 초과해서 요청하면 StackOverFlowError 익셉션이 발생된다.<메소드 영역>  
method area는 모든 JVM 쓰레드가 공유하는 스토리지이다. 런타임 상수 풀, 메소드 정보, 필드 정보, 메소드와 생성자의 바이트코드를 저장한다. JVM 스펙은 메소드 영역에 대한 일반적인 특징만 상세할 뿐 위치나 어떻게 구현해댜하는지에 대한 것은 
명령하지 않는다. 메소드 영역은 고정 size일수도, 증가하거나 줄일 수도 있다. 프로그래머는 메소드 영역의 초기 사이즈를 정할 수 있고, 근접하지 않아도 된다.<레지스터>  JVM에 의해 관리되는 register는 컴퓨터 시스템의 레지스터와 비슷하다. 
머신의 현재 상태를 반영하고 실행되는 바이트코드로 업데이트된다. 초기의 레지스터는 현재 실행되고 있는 JVM 명령어의 주소값을 가리키는 pc register (program counter)였다. 만약 현재 메소드가 네이티브 (자바가 아닌 언어로 작성된 것)로 
실행되고 있다면 pc 레지스터의 값은 정의되지 않는다. JVM의 다른 레지스터는 실행 중인 메소드의 실행 환경을 가리키는 포인터, 실행 중인 메소드의 첫번 째 로컬 변수를 가리키는 포인터, 피연산자의 꼭대기를 가리키는 포인터를 포함한다.<런타임 상수 
풀>  runtime constant pool은 다른 프로그래밍 언어의 기호 테이블과 비슷하다. 이름에서 알 수 있듯이, 숫자와 필드명을 포함한 상수들을 포함한다. 각각의 런타임 상수 풀을 위한 메모리는 메소드 영역에 할당되며, JVM이 클래스나 인터페이스에 
대한 클래스 파일을 로드할 때 생성된다.<가비지 콜렉터>  C언어 같은 옛날 언어들은 프로그래머가 명시적으로 메모리를 할당하거나 해제하도록 요청하였다.  메모리는 필요하면 할당되고 애플리케이션이 더 이상 필요하지 않으면 해제된다.  불행하게도, 이 
접근은 종종 메모리가 할당되고 절대 해제되지 않는 "memory leak"을 야기한다. 이것이 반복적으로 발생하면 애플리케이션은 결국 메모리가 부족하거나 비이상적으로 종료하거나 최소 더 이상 기능하지 않을 것이다. 반대로, 자바는 발생 가능한 많은 
문제를 방지하면서 프로그래머에게 명시적으로 메모리를 할당하거나 해제하라고 요청하지 않는다. 대신, 자바는 너가 객체를 생성할 때 자동으로 메모리가 할당되고, 객체 참조가 더 이상 존재하지 않을 때 자바는 메모리를 해제할 것이다.  자바는 이 때 
garbage collector을 사용하며 이것은 실행중인 자바 프로그램을 모니터링하고 더 이상 사용하지 않는 객체가 사용 중인 메모리를 자동으로 해제한다. 자바는 객체 참조를 추적하기 위해 일련의 soft pointer와 소프트 포인터와 객체 참조의 연결 
관계를 가지고 있는 object table을 사용한다. 소프트 포인터는 객체를 직접적으로 가리키는 것이 아닌 객체 자신의 참조값을 가리키기 때문에 소프트라고 이름지어졌다. 소프트 포인터를 사용함으로써 자바의 가비지 콜렉터는 분리된 쓰레드를 사용하며 
백그라운드에서 실행할 수 있고, 한 개의 오브젝트를 한번에 조사할 수 있다. 가비지 콜렉터는 객체 테이블의 엔트리를 변경함으로써 객체를 표시, 제고, 이동, 조사할 수 있다.  가비지 콜렉터는 자체적으로 실행되며, 명시적은 가비지 콜렉터 요청은 
일반적으로 불필요하다. 가비지 콜렉터는 프로그램이 실행하는 동안 간헐적으로 객체 참조를 체크하며 객체에 대한 참조가 더 이상 존재하지 않을 땐 할당된 메모리에 대한 반환을 요청한다. System 클래스의 gc() 메소드로 가비지 콜렉터가 실행되도록 
요청할 수 있지만 주어진 시간에 객체가 가비지 수집될 것이라는 보장은 없다.<<JVM: 로드, 링크, 초기화>>  JVM이 자바 바이트코드를 해석하기 위해선, 요구되는 클래스와 인터페이스에 대해 다음의 세 단계를 반드시 따라야한다.
	1. Loading: JVM이 클래스를 로드하면, 클래스와 인터페이스의 바이너리 상징(보통 자바컴파일러에 의해 생성된 클래스 파일)을 찾고 Class 객체를 생성한다. Class 객체는 클래스나 인터페이스의 런타임 상태를 캡슐화한다.
	2. Linking: 링킹은 로드된 클래스나 인터페이스를 가져와서 JVM 런타임에 결합시키고 실행을 위한 준비를 한다.
	3. Initializing: 초기화는 JVM이 클래스나 인터페이스의 초기화 메소드를 호출할 때 발생한다.

<첫 번째 스텝>  독립된 자바 애플리케이션이 시작할 때 JVM이 처음으로 하는 것은 public static void main(String[] args) 메소드를 포함하는 자바 클래스를 나타내는 Class 객체를 생성하는 것이다. JVM은 클래스를 링크와 초기화하고 
main() 메소드를 호출하며, 이 메소드는 추가적으로 참조되는 클래스와 인터페이스를 로딩, 링킹, 초기화한다.<Loading>  로딩 프로세스는 ClassLoader의 서브클래스인 클래스로더에 의해 실행된다; 클래스로더는 로딩한 클래스나 인터페이스의 몇가지 
검증을 실행한다. 컴파일된 클래스나 인터페이스의 바이너리 데이터가 비정상적일때 에러를 뿜는데, 클래스나 인터페이스가 클래스 파일 포맷을 지원되지 않는 버전을 사용한다거나 클래스 로더가 클래스나 인터페이스의 정의를 찾지 못하거나 재귀가 존재할 때가 
그런 경우이다. CLass 재귀는 클래스나 인터페이스가 자체가 부모클래스인 경우이다.  일반적으로 두 종류의 클래스로더가 존재한다: JVM이 공급하는 bootstrap class loader와 사용자 정의 클래스 로더들이다. 사용자 정의 클래스로더는 자바의 
ClassLoader 클래스를 상속받아야하고 비표준이고 사용자의 정의 소스로부터 Class 객체를 생성하는데 사용할 수 있다. 예를 들어,  Class 객체는 암호화된 파일로부터 추출될 수 있다. 로더는 로딩 프로세스의 일부 혹은 전부를 다른 로더에게 위힘할 
수 있지만. 궁극적으로 Class 객체를 만드는 객체를 defining loader라 한다. 로딩 프로세스를 시작하는 로더는 initiating loader라 한다.  디폴트 bootstrap loader를 사용하는 로딩 프로세스는 다음과 같은 일을 한다: 로더는 첫 째로 
요구되는 클래스 파일에 일치하는 클래스가 initiating loader에 의해 기록되었는지 확인한다.  만약 있다면, 즉 Class 객체가 이미 존재한다면 로더는 중지한다. (클래스를 로딩하는게 객체를 생성하는 것과 다르다는 것을 알아야한다; 이 과정은 단지 
JVM이 클래스를 사용할 수 있도록 만들어주는 것이다.) 만약 로드되지 않았다면, 로더는 클래스파일을 탐색하고 찾았다면 그 파일로부터 Class 객체를 생성한다. 만약 클래스 파일을 못 찾았다면 NoClassDefFoundError 익셉션이 생성된다.  사용자정의 
클래스로더가 사용되먄 프로세스는 다르게 흘러간다. 부트스트랩 로더와 같이, 사용자정의 로더도 처음에 요구되는 클래스파일에 대응하는 클래스가 initiating loader로더에 의해 기록되었는지 판별한다. 가지고 있다면 Class 객체는 이미 존재한 것이고 
로더는 중지하며, 존재하지 않는다면 사용자정의 로더는 loadClass() 메소드를 호출한다. 반환값은 요구되는 클래스파일이며 loadClass() 메소드는 클래스를 나타내는 바이트코드들의 배열을 ClassFile 구조체로 모은다. 그다음 ClassFile 
구조체로부터 Class 객체를 생성하는 defineClass()가 호출되면, 대안적으로 loadClass()  메소드는 간단하게 다른 클래스로더에게 로딩을 위임할 수 있다.<Linking>  링킹 프로세스가 처음으로 하는 일은 링크되야 하는 클래스파일을 검증하는 
것이다.<자바 클래스 파일 검증>  JVM이 자바 컴파일러와 완전히 분리되어있기 때문에 클래스파일을 해석하는 JVM은 클래스파일이 적절하게 형성되었거나 심지어 자바 컴파일러에 의해 생성되었다고 보증하지 않는다. 또 다른 문제는 상속과 클래스 호환성이다. 
만약 주어진 클래스 파일이 다른 클래스 파일의 수퍼클래스로부터 상속받는다면 JVM은 자식 클래스 파일이 수퍼클래스 파일과 호환가능한지 확인해야한다.  비록 자바클래스 검증기가 자바 언어와는 독립적이지만 JVM은 각 클래스파일이 자바 언어 스펙의 
제약조건을 만족하는지 검증한다. 다른 언어로 쓰여진 프로그램도 클래스파일고 컴파일 될 수 있고 (모든게 정확하다면) 검증 프로세스도 통과할 수 있다.  검증 프로세스는 4단계로 이루어진다:
	1. 첫 번째로, JVM에 의해 클래스파일이 로드되고 클래스파일의 기본 포맷에 충실한지 확인한다. 클래스파일은 정확한 길이여야한다. 매직 넘버 (진짜 클래스가 될수 있는지 클래스파일을 식별하는) 가 검증된다. 상수 풀은 인식할 수 없는 정보는 
포함되지 않아야 하고 각 속성의 길이는 올바른 길이인지 체크해야한다.
	2. 검증 프로세스의 두번째 단계는 파일이 링크될 때 발생한다. 이 과정에서는 final 키워드 제약조건이 준수되는지 보증하는 과정을 포함한다. 이 뜻은 final class는 상속받을 수 없고 final 메서드는 오버라이드 할 수 없다는 것이다. 상수 
풀은 원소들이 어떤 언어의 제약조건도 위반하지 않는지 확인한다. 상수 풀 안의 모든 필드와 메서드 참조들은 검증되었고, Object클래스를 제외한 모든 클래스들이 직접적인 수퍼클래스가 있는지 검증받는다.  
	3. 세 번째 검증 스텝 또한 링킹 과정에서 일어난다. 클래스 파일의 모든 참조된 메서드는 자바언어의 메서드 제약조건에 충실한지 확인받는자. 메서드들은 올바른 숫자와 인자 타입과 함께 호출되어야한다. operand stack은 똑같은 사이즈이고 같은 
타입의 값들을 포함해야한다. 지역 변수들은 접근되기 전에 적절한 값을 포함해야한다. 필드들은 적절한 타입의 값들만 할당되어야한다.
	4. 검증의 마지막 단계는 메소드가 처음 호출될 때 발생하는 이벤트를 보고 모든 것이 스펙에 따라 일어나는지 확인한다. 참조된 필드나 메소드가 주어진 클래스안에 존재하거나 혹은 적절한 설명자를 가지고 있거나 메서드가 실행할 때 참조된 메서드나 
필드에 접근하는지 검증한다.

<준비>  클래스파일이 검증되면, JVM은 클래스 변수에 메모리 공간을 할당함으로써 초기화를 위한 클래스를 준비하고 또한 디폴트 초기값을 설정한다. 이 값들은 int엔 0, boolean엔 false 등 표준 디폴트 값이다. 이 값들은 초기화 단계에서 프로그램에 
종속된 디폴트 값으로 설정된다.<분석> (Resolution?)  이 (선택적인) 단계에선 JVM이 런타임 상수 풀의  상징적인 참조들은 구체적인 값으로 분석한다.<초기화>  링킹 과정이 완료되면 static 필드와 static으로 초기화될 것들이 호출된다. 
static 필드들은 클래스의 인스턴스가 없어서 접근할 수 있는 값을 가지고 있다; static initializer는 정적 표현으로든 표현할 수 없는 static 초기화를 제공한다. 한 유형에 대한 모든 이니셜라이저는 JVM의 특수 메소드에 의해 수집된다. 예를 
들어 클래스를 위한 수집된 이니셜라이저는 초기화 메소드 <clinit>이 된다.  그러나 클래스를 초기화 할 때 JVM이 호출하는 (오직 JVM만 호출할 수 있는) 클래스 초기화 메소드 뿐만 아니라 모든 수퍼클래스도(<clinit> 호출에 연관된) 초기화되어야 
한다. 결과적으로 항상 처음으로 초기화되어지는 클래스는 Object 클래스이다. main() 메서드를 포함하는 클래스도 항상 초기화될 것이다.<바이트코드 실행>   클래스파일의 바이트코드는 수행되어야하는 명령어를 구체화한 1byte opcode(명령코드) 
명령어들의 연속으로 구성되어있다. 각 명령코드는 해당 연산에서 사용되는 인자나 데이터를 제공하는 0개 이상의 피연산자로 되어있다. JVM 인터프리터는 필수적으로 각 명령코드와 피연산자들을 로드하며 명령코드에 나타난 액션을 실행한다. 바이트코드는 JVM 
instruction set에 따라 액션으로 번역되는데, JVM instruction set은 바이트코드를 JVM 스펙에 의해 명세된 바이트코드로 나타낸 명령어와 매핑시킨다. 이 과정은 모든 명령코드가 해석될 때까지 지속된다.  JVM instruction set의 첫 번째 
명령어 세트는 기본형 데이터 타입(primitive data type) 과 객체에서 수행되는 기본 명령어들을 포함한다. 사용된 명명법은 일반적으로 데이터 타입 다음에 연산이 사용된다. 예를들어 iload 명령어(iload는 단순히 실제 명령어를 기억한다.) 는 
피연산자에서 int로 로드된 지역 변수를 나타낸다. 또 fload는 피연산자에서 float로 로드된 지역변수를 로딩한다. 이처럼 피연산자 스택의 특정 데이터 타입의 값을 지역 변수에 저장한다든가, 피연산자로부터 상수를 로드한다든가, 한 개 이상의 지역 
변수값을 접근한다든가하는 일련의 명령어들이 있다.  명령어 셋의 두 번째 셋은 산술 연산에 관한 것이며, 일반적으로 현재 피연산자 스택에 있는 두 개의 값과 피연산자에 집어넣을 연산의 결과를 포함한다. 이 명명법은 이전과 같다; 예를 들어 iadd 
명령어는 두 개의 integer 값을 더하며, dadd 명령어는 두 개의 double 값을 더한다.  비슷하게, 몇 개의 명령어들은 기본적인 수학적 함수 (더하기, 빼기, 곱하기, 나누기) 를 나타내고, 몇 가지 명령어들은 논리적 연산 (OR, AND, NOT 
비트연산) 을 나타내고, 몇 가지들은 나머지 연산, 부정, 이동, 증가, 비교를 포함한 특정 함수에 특정되어있다.  JVM은 부동소수점연산이나 0으로 반올림 같은 같은 것을 할 때 IEEE 754 표준을 따른다. 일부 정수 연산 에서 - 예를 들어 0으로 
나눈다거나 - 오버플로 조건이 발생했을 때 부동 소수점 연산자가 runtime 익셉션을 발생하는 대신 NaN("Not a Number" - 수학적 연산의 결과 유효하지 않음) 를 반환할 때 ArithmeticException을 던질 수 있다.  JVM 명령어 셋은 두 개의 
다른 타입을 전환할 수 있는 명령어를 포함하고 있다. JVM은 widening conversions (확대형변환, ex. float -> double). 네이밍 컨벤션은 첫 번째 타입 뒤에 2뒤에 두 번째 타입을 붙인다. 예를 들어 i2l은 int에서 long으로의 변환을 
뜻한다. 이 명령어 셋은 narrowing operations (축소형변환) 또한 포함한다 (ex. int -> char).명명법은 확대형변환과 같다.  명령어들은 클래스와 배열 객체들을 생성하고 조작하기 위해 존재한다. new 명령어는 새 클래스 객체를 생성하고, 
newarray, anewarray, multilinearray 명령어들은 배열 객체를 생성한다. 명령어들은 또한 클래스의 static 과 인스턴스 변수에 접근하거나, 피연산자 스택의 배열 구성요소를 로드하거나, 피연산자 스택의 값을 배열 구성요서로 저장하거나, 배열 
길이를 리턴하거나, 클래스 객체나 배열의 특정 속성 값을 체크하기도 한다.  JVM 명령어 셋은 함수를 호출하기 위한 invokevirtual, invokeinterface, invokespecial, invokestatic 명령어가 있으며 invokevirtual 은 normal 
method dispatch mode 이다. 다른 명령어들은 인터페이스나, 특별한 핸들링이 필요한 private 이나 수퍼클래스의 메소드나, static 메소드에 의해 구현된 함수를 위한 것이다. 메소드 리턴 명령도 각 데이터 타입에 의해 정의된다.  또 다른 JVM 
명령어 중 Java7 스펙에 추가된 invokedynamic을 언급하는 것이 가치있다. 역설적으로, 그 명령어는 그 때 릴리즈된 자바 언어에는 작은 영향을 미쳤지만 Java8에 소개된 자세히는 Chaptor3에서 배울 lambda에 큰 변화를 위한 틀을 제공해주었다. 
최근의 호출 명령어 (invokevirtual, invokeinterface 등)emfdms "static linking" 이라는 것들만 지원하였다; 즉 객체가 참조하는 타입이 컴파일 타임에 결정되는 것이다. 예를 들어 invokevirtual이 사용되는 경우 해당 메소드가 
정의된 객체 타입이 정의되어 있기 때문에 호출되는 메소드는 존재하는 것으로 알려져있었다. 이런 접근법은 컴파일 타임에 정의되고 후에 다른 타입으로 변경하거나 대체할 수 없기 때문에 정적 링크라고 부른다. 정적 링크와 대조되어 invokedynamic은 
호출된 메소드가 정의된 객체 타입이 런타임에 정해지며, 특정 범위안에 있는 한 어떤 타입이든 유효한 동적 링크를 지원한다.  특히, 메소드는 호출에 의해 구체화되고 메소드가 허용하는 조건을 만족하는 데이터 타입으로 구성되어 있는 파라미터를 허용해야 
한다. 비록 invokedynamic이 JVA 8 까지는 그렇게 영향이 있지 않더라고, 자바 이외에 JVM을 사용하는 다른 언어의 구현에 좋은 영향을 주었다.  마지막으로, 피연산자를 관리한다거나, 제어의 전이, 익셉션 발생, finally 키워드를 구현하는 것, 
동기화를 포함하여 다양한 연산을 하는 명령어 집합이 있다.  예를 들어, 다음의 간단한 자바 클래스를 생각보자:  이 클래스를 컴파일하고 javap 유틸리티에 -c (covered later) 옵션을 사용하여 클래스 파일을 해체하면 mnemonic (니모닉, 기억을 
돕는) 버전의 바이트코드를 볼 수 있다.    우리가 관심있어하는 니모닉의 메인 셋은 한 문장인 System.out.println("Hello World");이 번역되어 있는 main() 메소드 아래 세 문장이다; 코드의 라인이다.  첫 번째 명령어인 getstatic은 
java.lang.System 객체의 필드가 out인 PrintStream 객체를 반환하고 피연산자 스택에 집어넣는다. 다음 줄인 ldc는 String “Hello World!”를 피연산자 스택에 집어넣는다. 마지막으로 invokevirtual가 (java.io.PrintStream 
클래스의) println() 메소드를 실행한다. 메소드가 성공적으로 실행되면, String과 java.io.PrintStream 객체가 스택에 같은 순서로 쌓인다. 이 실행을 하고 이 아이템들은 스택에서 제거된다. <자바 클래스 파일 포맷>  이미 설명했듯이, JVM은 
자바언어를 직접적으로 인터프리트할 수 없어서 자바 코드가 컴파일되면 결과는 심볼 테이블인 바이트코드와 다른 정보들을 포함한 하나 이상의 클래스 파일이 만들어진다. 클래스 파일 구조는 정고햐게 정의된 바이너리 포맷이어서 JVM은 클래스파일이 어디서 
생성되었뜬 상관없이 어떤 클래스파일이라도 로드하고 인터프리트할 수 있다.  클래스파일은 8비트 바이트의 스트림으로 구성되어있다. 모든 상위 비트 (16, 32, 64비트)들은 8비트 바이트들의 조합으로 읽음으로써 생성되고 멀티바이트는 빅엔디언 순서(높은 
바이트가 먼저)로 저장된다. 자바 언어는 I/O 스트림(java.io 패키지의 DataInput, DataInputStream, DataOutput, DataOutputStream 클래스)을 제공하여 클래스파일을 읽고 쓸 수 있다.   클래스파일의 데이터 타입은 unsinged 1-, 
2-, 4-byte 이다. 이것들을 u1, u2, u4 로 표기한다. 클래스파일은 배열 같이 인덱싱 된 일련의 연속적인 고정 사이즈의 항목도 포함한다. 이것은 대괄호([])로 표기한다.   클래스 포맷은 하나의 ClassFile 구조체를 포함하는데, 이 구조체는 
JVM이 알아야하는 클래스나 인터페이스에 대한 모든 정보를 포함한다. 일반적인 ClassFile의 구조는 다음과 같다:   magic 파라미터는 클래스파일 형식에 지정된 매직 넘버이다. 값은 0xCAFEBABE를 가지며 코드를 클래스파일로 식별한다.  
major_version과 minor_version 항목은 클래스파일 포맷의 메이저와 마이너 버전이다. JVM에 있어서 버전 넘버는 어떤 포맷의 클래스파일을 지원하는지를 알려준다. JVM은 일반적으로 특정 버전 범위(예를 들어 한 메이버 버전 안의 다양한 마이너 
버전들) 안에서만 클래스파일을 로드할 수 있고 일반적으로 JVM 자체보다 새로운 스펙의 파일을 거부한다.  버전 이해하기  constant_pool_count 항목은 상수 풀에 포함된 요소들 +1 한 값과 같다. 이 변수는 constatnt_pool 인덱스가 유효할 
때만 결정된다. constant_pool[] 항목은 cp_info 구조체의 테이블이며 constant_pool 안의 원소들 정보를 포함한다.  access_flags 항목은 플래그 마스크인데 파일이 클래스인지 인터페이스인지 여부와 클래스와 인터페이스에 대한 접근 권한에 
대한 것을 반영한다. 마스크는 꺼질 수도 있고 public, final, super, interface, abstract 플래그들의 조합이 될 수 도 있다.  비트마스크, 비트플래그  this_class 인자는 constant_pool  테이블 안의 클래스파일에 의해 정의된 
클래스나 인터페이스를 나타내는 CONSTANT_Class_infor 구조체를 가리킨다. super_class 항목은 constant_pool 안의 직접적인 superclass나 인터페이스나 만약 superclass가 존재하지 않으면 0을 나타내는 요소를 가리킨다.   
interfaces_count 인자는 클래스나 인터페이스의 superinterface들의 개수를 나타낸다. interfaces[] 항목은 constant_pool 테이블안의 superinterface들의 위치를 포함한다.   field_count 변수는 ClassFile의 field_info 
구조체 개수 정보를 가지고 있다. filed_info 구조체는 클래스나 인터페이스에 선언된 static 필드와 인스턴스 필드를 포함한 모든 필드를 나타낸다. methods[] 항목은 methid_info 구조체를 포함하는 테이블이다.  마지막으로, 
attributed_count 변수는 클래스나 인터페이스의 attributes 테이블의 속성들 개수 정보를 가지고 있다. attributes[] 항목은 속성들의 구조체를 포함하는 테이블이다.<<자바 프로그래밍 언어와 API들>>    지금까지 일어난 모든 것은 
애플리케이션 개발자의 관점에서 투명하게 일어나는 일이다. 사실 자바 프로그램에 대하여 자바의 내부 아카텍처를 이해할 필요는 없다. 하지만 너가 알아야 하는 것은 자바를 프로그래밍 언어로써 사용하는 방법과 sw와 os에 기반하는 다양한 플랫폼과 소통할 
수 있는 다양한 API들을 사용하는 방법이다. 사실 자바로 효율적으로 개발하는 방법이 책의 나머지에서 필수적으로 다루는 것이다.<자바 프로그래밍 언어>  비록 다양한 API를 아는 것이 자바로 무언가를 할 때 필수적이긴 하지만 자바 언어 코어의 견고한 
기반도 API를 효율적으로 사용하기 위해서 매우 바람직하다. 이 책에서는 코어 자바 프로그래밍의 특징에 대하여 탐험할 것이다.
	* Method, Interface, class design
	* 쓰레드

...
블라블라블라 책에서 다룰 다음 내용 소개
